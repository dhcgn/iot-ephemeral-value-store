# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Project Overview

IoT Ephemeral Value Store is a Go-based HTTP server that provides temporary storage for IoT sensor data. It uses a key-pair system where devices upload data using an upload key, and consumers retrieve data using a derived download key. This separation ensures privacy and security.

Key design principle: All operations use HTTP GET requests to accommodate simple IoT devices.

## Common Commands

### Build and Test
```bash
# Build the project
go build -v ./...

# Run tests with coverage
go test -race -covermode atomic -coverprofile=coverage.txt ./...

# Run tests for a specific package
go test -v ./storage
go test -v ./httphandler

# Build with version information (using build script)
./scripts/build.sh [output-filename]

# Run the server locally
go run . -persist-values-for 24h -store ./data -port 8088
```

### Server Flags
- `-persist-values-for`: Data retention duration (e.g., "1d", "24h", "2h")
- `-store`: Storage directory path (default: "./data")
- `-port`: Server port (default: 8080)

## Architecture

### Key Generation and Security Model
The security model is based on key derivation:
1. **Upload Key**: 256-bit random hex string generated by `domain.GenerateRandomKey()`
2. **Download Key**: SHA256 hash of the upload key, derived by `domain.DeriveDownloadKey()`

This one-way derivation means:
- Upload keys can generate download keys but not vice versa
- IoT devices get upload keys (write-only access)
- Consumers get download keys (read-only access)
- Keys are validated in `domain/domain.go`

### Storage Layer
Uses BadgerDB (embedded key-value database) with TTL-based expiration:
- `storage.StorageInstance` wraps BadgerDB operations
- Data is stored as JSON blobs keyed by download key
- TTL is set per entry based on `-persist-values-for` flag
- Two storage modes: in-memory (testing) and persistent (production)
- See `storage/storage.go` for implementation

### HTTP Handler Architecture
The `httphandler` package contains all endpoint handlers:
- `keyPairHandler.go`: Generate new key pairs (`/kp`)
- `uploadHandler.go`: Upload data (`/u/{uploadKey}` and `/patch/{uploadKey}/{param}`)
- `downloadHandler.go`: Download data (`/d/{downloadKey}/json`, `/d/{downloadKey}/plain/{param}`)
- `deleteHandler.go`: Delete data (`/delete/{uploadKey}`)

Key upload patterns:
- **Simple upload** (`/u/{uploadKey}?key=value`): Replace all data
- **Patch upload** (`/patch/{uploadKey}/path?key=value`): Merge data into nested structure

The patch system (`UploadAndPatchHandler`) supports nested JSON paths, allowing multiple uploads to build complex data structures.

### Middleware Stack
Applied in order (see `main.go:createRouter`):
1. **CORS** (`middleware.EnableCORS`): Allow cross-origin requests
2. **Request Size Limit** (`middleware.LimitRequestSize`): Max 10KB requests
3. **Rate Limiting** (`middleware.RateLimit`): 100 req/s with burst of 10

### Statistics Tracking
The `stats` package tracks server metrics:
- Upload/download counts (total and 24h window)
- HTTP errors and rate limit hits
- Server uptime
- Used by info page and exposed via template data

### Router Configuration
Uses Gorilla Mux for routing (see `main.go:createRouter`):
- Supports both legacy (`/{uploadKey}`) and new (`/u/{uploadKey}`) routes
- Nested path parameters use `{param:.*}` regex for arbitrary depth
- Static files embedded using `go:embed` directive
- Templates rendered for info page (`/`) and viewer (`/viewer`)

## Data Flow

### Upload Flow
1. Client makes GET request: `/u/{uploadKey}?tempC=23&humidity=45`
2. `uploadHandler.go:handleUpload` validates upload key
3. Download key derived from upload key
4. Query parameters collected and timestamp added
5. Data merged (if patch) or replaced in storage
6. Response includes download URLs for JSON and individual fields

### Download Flow
1. Client requests: `/d/{downloadKey}/json` or `/d/{downloadKey}/plain/{field}`
2. `downloadHandler.go` retrieves data from storage by download key
3. For JSON: return entire stored object
4. For plain: extract specific field from JSON, optionally decode base64
5. Download-root page (`/d/{downloadKey}/`) lists all available fields

### Patch Mechanism
The patch system merges data at nested paths:
- `/patch/{uploadKey}/?temp=23` → stores at root level
- `/patch/{uploadKey}/house_1/?temp=30` → stores at `house_1.temp`
- `/patch/{uploadKey}/house_1/room/?temp=25` → stores at `house_1.room.temp`

Implementation in `httphandler/datahandling.go:mergeData()` recursively builds nested maps.

## Testing Patterns

### Test Structure
All packages have `_test.go` files:
- Use `storage.NewInMemoryStorage()` for test storage
- Router tests in `main_router_test.go` use `httptest.NewRecorder()`
- Middleware tests verify behavior under various conditions

### Running Specific Tests
```bash
# Test a single function
go test -v -run TestFunctionName ./package

# Test with race detector
go test -race ./...

# Test with coverage for specific package
go test -cover ./httphandler
```

## Web Interface

The server includes self-hosted web pages:
- **Info page** (`/`): Server stats, example URLs, API documentation
- **Viewer** (`/viewer`): Real-time monitoring tool for watching multiple keys
- Both use templates in `static/` directory (embedded at build time)

## Build System

Version information is injected at build time:
- `Version`, `BuildTime`, `Commit` variables in `main.go`
- Build scripts in `scripts/` handle version extraction from git tags
- Version format: `v1.0.0` or `v1.0.0+5` (commits since tag)

## Dependencies

Core dependencies (see `go.mod`):
- `github.com/gorilla/mux`: HTTP routing
- `github.com/dgraph-io/badger/v3`: Embedded database
- `golang.org/x/time/rate`: Rate limiting
- `github.com/stretchr/testify`: Testing utilities

## Important Implementation Notes

1. **All operations use GET requests** to support simple IoT devices
2. **Keys are 256-bit hex strings** (64 characters when encoded)
3. **Timestamps are added automatically** to uploaded data
4. **TTL is set per entry** when storing, not globally
5. **BadgerDB cleanup** happens automatically via TTL expiration
6. **Download keys cannot be reverse-engineered** to upload keys (SHA256 is one-way)
7. **Nested paths in patch mode** are split on `/` and converted to nested JSON objects
